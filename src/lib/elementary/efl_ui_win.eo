import efl_orientation;

enum Efl.Ui.Win_Type
{
   [[Defines the types of window that can be created

     These are hints set on a window so that a running Window Manager knows
     how the window should be handled and/or what kind of decorations it
     should have.

     Currently, only the X11 backed engines use them.
   ]]
   legacy: efl_ui_win;

   unknown = -1, [[Default, unknown, type]]
   basic, [[A normal window. Indicates a normal, top-level window. Almost every
            window will be created with this type.]]
   dialog_basic, [[Used for simple dialog windows.]]
   desktop, [[For special desktop windows, like a background window holding
              desktop icons.]]
   dock, [[The window is used as a dock or panel. Usually would be kept on top
           of any other window by the Window Manager.]]
   toolbar, [[The window is used to hold a floating toolbar, or similar.]]
   menu, [[Similar to @.toolbar.]]
   utility, [[A persistent utility window, like a toolbox or palette.]]
   splash, [[Splash window for a starting up application.]]
   dropdown_menu, [[The window is a dropdown menu, as when an  entry in a
                    menubar is clicked.
                    This hint exists for completion only, as the EFL way of
                    implementing a menu would not normally use a separate
                    window for its contents.]]
   popup_menu, [[Like @.dropdown_menu, but for the menu triggered by
                 right-clicking an object.]]
   tooltip, [[The window is a tooltip. A short piece of explanatory text that
              typically appear after the mouse cursor hovers over an object
              for a while. Typically not very commonly used in the EFL.]]
   notification, [[A notification window, like a warning about battery life or
                   a new E-Mail received.]]
   combo, [[A window holding the contents of a combo box. Not usually used in
            the EFL.]]
   /* Some types have been removed from EO. Skipping to 17. */
   naviframe_basic = 17 [[Used for naviframe style replacement with a back
                          button instead of a close button.
                          @since 1.19
                        ]]
}

enum Efl.Ui.Win_Keyboard_Mode
{
   [[The different layouts that can be requested for the virtual keyboard.

     When the application window is being managed by Illume it may request
     any of the following layouts for the virtual keyboard.
   ]]
   legacy: efl_ui_win_keyboard;

   unknown, [[Unknown keyboard state]]
   off, [[Request to deactivate the keyboard]]
   on, [[Enable keyboard with default layout]]
   alpha, [[Alpha (a-z) keyboard layout]]
   numeric, [[Numeric keyboard layout]]
   pin, [[PIN keyboard layout]]
   phone_number, [[Phone keyboard layout]]
   hex, [[Hexadecimal numeric keyboard layout]]
   terminal, [[Full (QWERTY) keyboard layout]]
   password, [[Password keyboard layout]]
   ip, [[IP keyboard layout]]
   host, [[Host keyboard layout]]
   file, [[File keyboard layout]]
   url, [[URL keyboard layout]]
   keypad, [[Keypad layout]]
   j2me [[J2ME keyboard layout]]
}

enum Efl.Ui.Win_Indicator_Mode
{
   [[Defines the type indicator that can be shown]]
   legacy: efl_ui_win_indicator;

   off, [[Request to deactivate the indicator]]
   bg_opaque, [[The indicator icon is opaque, as is the indicator background.
                The content of window is located at the end of the indicator.
                The area of indicator and window content are not overlapped]]
   bg_transparent, [[The icon of indicator is opaque, but the background is transparent.
                     The content of window is located under the indicator in Z-order.
                     The area of indicator and window content are overlapped]]
   hidden [[The indicator is hidden so user can see only the content of window such as in video mode.
            If user flicks the upper side of window, the indicator is shown temporarily.]]
}

enum Efl.Ui.Win_Keygrab_Mode
{
   [[Define the keygrab modes of window. A window may send commands to the
     Keyrouter according this mode, and perform different actions.]]

   legacy: efl_ui_win_keygrab;
   unknown = 0, [[Unknown keygrab mode]]
   shared = (1 << 8), [[Get the grabbed-key together with the other client
                        windows]]
   topmost = (1 << 9), [[Get the grabbed-key only when window is top of the
                         stack]]
   exclusive = (1 << 10), [[Get the grabbed-key exclusively regardless of
                            window's position]]
   override_exclusive = (1 << 11) [[Get the grabbed-key exclusively
                                    regardless of window's position. This is
                                    overrided by grabs from the other client
                                    window]]
}

enum Efl.Ui.Win_Modal_Mode
{
   [[Defines the mode of a modal window]]
   legacy: efl_ui_win_modal;

   none, [[The window is not modal window.]]
   modal [[The window is modal window.]]
}

enum Efl.Ui.Win_Urgent_Mode
{
   [[Defines the mode of a urgent window.]]
   legacy: efl_ui_win_urgent;

   none,  [[The window is not a urgent window.]]
   urgent [[The window is a urgent window.]]
}

enum Efl.Ui.Win_Move_Resize_Mode
{
   [[Define the move or resize mode of window.

     The user can request the display server to start moving or resizing
     the window by combining these modes. However only limited combinations
     are allowed.

     Currently, only the following 9 combinations are permitted.
     More combinations may be added in future:
     1. move,
     2. top,
     3. bottom,
     4. left,
     5. right,
     6. top | left,
     7. top | right,
     8. bottom | left,
     9. bottom | right.

     @since 1.19
   ]]
   legacy: efl_ui_win_move_resize;

   move = 1,           [[Start moving window]]
   top = (1 << 1),     [[Start resizing window to the top]]
   bottom = (1 << 2),  [[Start resizing window to the bottom]]
   left = (1 << 3),    [[Start resizing window to the left]]
   right = (1 << 4)    [[Start resizing window to the right]]
}

class @beta Efl.Ui.Win extends Efl.Ui.Widget implements Efl.Canvas.Scene, Efl.Access.Window,
                  Efl.Access.Component, Efl.Access.Widget.Action,
                  Efl.Content, Efl.Input.State, Efl.Input.Interface, Efl.Screen,
                  Efl.Text, Efl.Config,
                  Efl.Ui.Widget_Focus_Manager, Efl.Ui.Focus.Manager_Window_Root
{
   [[Efl UI window class]]
   legacy_prefix: elm_win;
   methods {
      @property indicator_mode {
           [[In some environments you may have an indicator that
           shows battery status, reception, time etc. This is the indicator.

           Sometimes you don't want this because you provide the same functionality
           inside your app, so this will request that the indicator is disabled in
           such circumstances. The default settings depends on the environment.
           For example, on phones, the default is to enable the indicator.
           The indicator is disabled on devices like televisions however.

           @since 1.18
         ]]
         set {
            legacy: null;
         }
         get {
            legacy: null;
         }
         values {
            type: Efl.Ui.Win_Indicator_Mode; [[The mype, one of @Efl.Ui.Win_Indicator_Mode.]]
         }
      }
      @property keyboard_mode {
         set {
            [[Sets the keyboard mode of the window.]]
         }
         get {
            [[Get the keyboard mode of the window.]]
         }
         values {
            mode: Efl.Ui.Win_Keyboard_Mode; [[The mode, one of @Efl.Ui.Win_Keyboard_Mode.]]
         }
      }
      @property wm_available_rotations {
         [[Defines which rotations this window supports.

           The window manager will refer to these hints and rotate the window
           accordingly, depending on the device orientation, for instance.
         ]]
         values {
            allow_0: bool; [[Normal orientation.]]
            allow_90: bool; [[Rotated 90 degrees CCW.]]
            allow_180: bool; [[Rotated 180 degrees.]]
            allow_270: bool; [[Rotated 270 degrees CCW (i.e. 90 CW).]]
         }
         set {
            legacy: null;
         }
         get {
            legacy: null;
            return: bool; [[Returns $false if available rotations were
                            not specified.]]
         }
      }
      @property wm_available_profiles {
         [[Available profiles on a window.]]
         set {
            legacy: null;
         }
         get {
            legacy: null;
         }
         values {
            profiles: const(array<string>); [[A list of profiles.]]
         }
      }
      @property screen_constrain {
         set {
            [[Constrain the maximum width and height of a window to the
              width and height of the screen.

              When $constrain is $true, $obj will never resize larger than
              the screen.
            ]]
         }
         get {
            [[Get the constraints on the maximum width and height of a
              window relative to the width and height of the screen.

              When this function returns $true, $obj will never resize
              larger than the screen.
            ]]
         }
         values {
            constrain: bool; [[$true to restrict the window's maximum size.]]
         }
      }
      @property prop_focus_skip {
         set {
            [[Set the window to be skipped by keyboard focus.

              This sets the window to be skipped by normal keyboard input.
              This means a window manager will be asked not to focus this
              window as well as omit it from things like the taskbar, pager,
              "alt-tab" list etc. etc.

              Call this and enable it on a window BEFORE you show it for
              the first time, otherwise it may have no effect.

              Use this for windows that have only output information or
              might only be interacted with by the mouse or touchscreen,
              never for typing. This may have
              side-effects like making the window non-accessible in
              some cases unless the window is specially handled. Use
              this with care.
            ]]
         }
         values {
            skip: bool; [[The skip flag state ($true if it is to be skipped).]]
         }
      }
      @property autohide {
         [[Window's autohide state.

           When closing the window in any way outside of the program control,
           like pressing the X button in the titlebar or using a command from
           the Window Manager, a "delete,request" signal is emitted to indicate
           that this event occurred and the developer can take any action, which
           may include, or not, destroying the window object.

           When this property is set to $true, the window will be automatically
           hidden when this event occurs, after the signal is emitted. If this
           property is $false nothing will happen, beyond the event emission.

           C applications can use this option along with the quit policy
           $ELM_POLICY_QUIT_LAST_WINDOW_HIDDEN which allows exiting EFL's main
           loop when all the windows are hidden.

           Note: $autodel and $autohide are not mutually exclusive. The window
           will be deleted if both are set to $true.
         ]]
         values {
            autohide: bool; [[If $true, the window will automatically hide
                              itself when closed.]]
         }
      }
      @property exit_on_close {
         [[Enable quitting the main loop when this window is closed.

           When set, the window's loop object will exit using the passed exit code if the
           window is closed.

           The Eina.Value passed should be $EMPTY to unset this state or an int value to be
           used as the exit code.
         ]]
         values {
            exit_code: const(any_value_ptr); [[The exit code to use when exiting]]
         }
      }
      @property icon_object {
         set {
            [[Set a window object's icon.

              This sets an image to be used as the icon for the given
              window, in the window manager decoration part. The exact
              pixel dimensions of the object (not object size) will be
              used and the image pixels will be used as-is when this
              function is called. If the image object has been updated,
              then call this function again to source the image pixels
              and place them in the window's icon. Note that only objects of
              type @Efl.Canvas.Image or @Efl.Ui.Image are allowed.
            ]]
            values {
               icon: Efl.Canvas.Object @nullable;
                  [[The image object to use for an icon.]]
            }
         }
         get {
            [[Get the icon object used for the window.

              The object returns is the one marked by @.icon_object.set as
              the object to use for the window icon.
            ]]
            values {
               icon: const(Efl.Canvas.Object) @nullable;
                  [[The Evas image object to use for an icon.]]
            }
         }
      }
      @property iconified {
         set {
            [[Set the iconified state of a window.]]
         }
         get {
            [[Get the iconified state of a window.]]
         }
         values {
            iconified: bool; [[If $true, the window is iconified.]]
         }
      }
      @property maximized {
         set {
            [[Set the maximized state of a window.]]
         }
         get {
            [[Get the maximized state of a window.]]
         }
         values {
            maximized: bool; [[If $true, the window is maximized.]]
         }
      }
      @property fullscreen {
         set {
            [[Set the fullscreen state of a window.]]
         }
         get {
            [[Get the fullscreen state of a window.]]
         }
         values {
            fullscreen: bool; [[If $true, the window is fullscreen.]]
         }
      }
      @property sticky {
         set {
            [[Set the sticky state of the window.

              Hints the Window Manager that the window in $obj should be
              left fixed at its position even when the virtual desktop
              it's on moves or changes.
            ]]
         }
         get {
            [[Get the sticky state of the window.]]
         }
         values {
            sticky: bool; [[If $true, the window's sticky state is enabled.]]
         }
      }
      @property urgent {
         set {
            [[Set the urgent state of a window.]]
            legacy: null;
         }
         get {
            [[Get the urgent state of a window.]]
            legacy: null;
         }
         values {
            urgent: Efl.Ui.Win_Urgent_Mode;
                [[The mode of a urgent window, one of @Efl.Ui.Win_Urgent_Mode.]]
         }
      }
      @property modal {
         set {
            [[Set the modal state of a window.]]
            legacy: null;
         }
         get {
            [[Get the modal state of a window.]]
            legacy: null;
         }
         values {
            modal: Efl.Ui.Win_Modal_Mode; [[The mode of a window, one of @Efl.Ui.Win_Modal_Mode.]]
         }
      }
      @property noblank {
         set {
            [[Set the noblank property of a window.

              The "noblank" property is a way to request the display on
              which the window is shown does not blank, go to screensaver or
              otherwise hide or obscure the window. It is intended for
              uses such as media playback on a television where a user
              may not want to be interrupted by an idle screen. The
              noblank property may have no effect if the window is
              iconified/minimized or hidden.

              @since 1.11
            ]]
         }
         get {
            [[Get the noblank property of a window.

              @since 1.11
            ]]
         }
         values {
            noblank: bool; [[If $true, the window is set to noblank.]]
         }
      }
      @property borderless {
         set {
            [[Set the borderless state of a window.

              This function requests the Window Manager not to draw any
              decoration around the window.
            ]]
         }
         get {
            [[Get the borderless state of a window.]]
         }
         values {
            borderless: bool; [[If $true, the window is borderless.]]
         }
      }
      @property win_role {
         /* FIXME: Do we actually need this? There is only support in X. */
         [[The role of the window.

           It is a hint of how the Window Manager should handle it. Unlike
           @.win_type and @.win_name this can be changed at runtime.
         ]]
         set {
            [[Set the role of the window.]]
            legacy: elm_win_role_set;
         }
         get {
            [[Get the role of the window.

              The returned string is an internal one and should not be
              freed or modified. It will also be invalid if a new role
              is set or if the window is destroyed.
            ]]
            legacy: elm_win_role_get;
         }
         values {
            role: string; [[The role to set.]]
         }
      }
      @property win_name {
         [[The window name.

           The meaning of name depends on the underlying windowing system.

           The window name is a construction property that can only be set at
           creation time, before finalize. In C this means inside $efl_add().

           Note: Once set, it cannot be modified afterwards.
         ]]
         set {
            [[Name can only be set before finalize.]]
            legacy: null;
         }
         get {
            [[ @since 1.18 ]]
            legacy: elm_win_name_get;
         }
         values {
            name: string @nullable; [[Window name]]
         }
      }
      @property win_type {
         [[The type of the window.

           It is a hint of how the Window Manager should handle it.

           The window type is a construction property that can only be set at
           creation time, before finalize. In C this means inside $efl_add().

           Note: Once set, it cannot be modified afterward.
         ]]
         set {
            [[Type can on be set before finalize.]]
            legacy: null;
         }
         get {
            [[If the object is not window object, returns $unknown.]]
            legacy: elm_win_type_get;
         }
         values {
            type: Efl.Ui.Win_Type(Efl.Ui.Win_Type.unknown); [[Window type]]
         }
      }
      @property accel_preference {
         [[The hardware acceleration preference for this window.

           This is a constructor function and can only be called before
           @Efl.Object.finalize.

           This property overrides the global EFL configuration option
           "accel_preference" for this single window, and accepts the same
           syntax.

           The $accel string is a freeform C string that indicates
           what kind of acceleration is preferred. Here "acceleration" generally
           refers to rendering and the hardware with which the unit application renders GUIs.
           This may or may not be honored but a best attempt will
           be made. Known strings are as follows:

           "gl", "opengl" - try use OpenGL.
           "3d" - try to use a 3d acceleration unit.
           "hw", "hardware", "accel" - try any acceleration unit (best possible)
           "none" - use no acceleration but software instead (since 1.16)

           Since 1.14, it is also possible to specify some GL properties for the GL
           window surface. This allows applications to use GLView with depth, stencil
           and MSAA buffers with direct rendering. The new accel preference string
           format is thus "{HW Accel}[:depth{value}[:stencil{value}[:msaa{str}$]$]$]".

           Accepted values for depth are for instance "depth", "depth16", "depth24".
           Accepted values for stencil are "stencil", "stencil1", "stencil8".
           For MSAA, only predefined strings are accepted: "msaa", "msaa_low",
           "msaa_mid" and "msaa_high". The selected configuration is not guaranteed
           and is only valid in case of GL acceleration. Only the base acceleration
           string will be saved (e.g. "gl" or "hw").

           Full examples include:

           "gl", - try to use OpenGL
           "hw:depth:stencil", - use HW acceleration with default depth and stencil buffers
           "opengl:depth24:stencil8:msaa_mid" - use OpenGL with 24-bit depth,
                8-bit stencil and a medium number of MSAA samples in the backbuffer.

           Note that this option may be overriden by environment variables
           or the configuration option "accel_preference_override".

           @since 1.18
         ]]
         values {
            accel: string; [[Acceleration]]
         }
         set {
            legacy: null;
         }
         get {
            [[This will return the value of "accel_preference" when the window
              was created.]]
         }
      }
      @property alpha {
         set {
            [[Set the alpha channel state of a window.

              If $alpha is true, the alpha channel of the canvas will be
              enabled possibly making parts of the window completely or
              partially transparent. This is also subject to the underlying
              system supporting it, for example a system using a
              compositing manager.

              Note: Alpha window can be enabled automatically by window
              theme style's property. If "alpha" data.item is "1" or
              "true" in window style(eg. elm/win/base/default), the window
              is switched to alpha automatically without the explicit api
              call.
            ]]
         }
         get {
            [[Get the alpha channel state of a window.]]
         }
         values {
            alpha: bool; [[$true if the window alpha channel is enabled,
                           $false otherwise.]]
         }
      }
      @property stack_id @beta {
         get {
            [[Get the stack ID string of the window as an opaque string.

              This ID is immutable and can never be modified. It will be
              an opaque string that has no specific defined format or
              content other than being a string (no character with a
              value of 0).

              This string is intended for use as a stack master ID to be
              use by other windows to make this window part of a stack
              of windows to be placed on top of each other as if they are
              a series of dialogs or questions one after the other, allowing
              you to go back through history.]]
         }
         values {
            id: string; [[An opaque string that has no specific format
                          but identifies a specific unique window on the
                          display.]]
         }
      }
      @property stack_master_id @beta {
         set {
            [[Set the window stack ID to use as the master top-level.

              This sets the ID string to be used as the master top-level
              window as the base of a stack of windows. This must be set
              before the first time the window is shown and should never
              be changed afterwards.]]
         }
         get {
            [[Get the stack master Id that has been set.]]
         }
         values {
            id: string; [[An opaque string that has no specific format,
                          but identifies a specific unique window on the
                          display.]]
         }
      }
      @property stack_base @beta {
         [[The stack base state of this window

           This is a boolean flag that determines if this window will
           become the base of a stack at all. You must enable this
           on a base (the bottom of a window stack) for things to work
           correctly.

           This state should be set before a window is shown for the
           first time and never changed afterwards.]]

         set {}
         get {}
         values {
            base: bool; [[$true if this is a stack base window, $false
                          otherwise.]]
         }
      }
      stack_pop_to @beta {
         [[Pop (delete) all windows in the stack above this window.

           This will try and delete all the windows in the stack that
           are above the window.]]
      }
      @property exit_on_all_windows_closed @class {
         [[Enable quitting the main loop when all windows are closed.

           When set, the main loop will quit with the passed exit code once all windows have been closed.

           The Eina.Value passed should be $EMPTY to unset this state or an int value to be
           used as the exit code.
         ]]
         values {
            exit_code: const(any_value_ptr); [[The exit code to use when exiting]]
         }
      }
      activate {
         [[Activate a window object.

           This function sends a request to the Window Manager to activate
           the window pointed by $obj. If honored by the WM, the window
           will receive the keyboard focus.

           Note: This is just a request that a Window Manager may ignore,
           so calling this function does not ensure in any way that the
           window will be the active one afterwards.
         ]]
      }
      center {
         [[Center a window on the screen.

           This function centers window $obj horizontally and/or vertically
           based on the values of $h and $v.

           Note: This is just a request that a Window Manager may ignore,
           so calling this function does not ensure in any way that the
           window will be centered afterwards.
         ]]
         params {
            @in h: bool; [[If $true, center horizontally. If $false, do not change horizontal location.]]
            @in v: bool; [[If $true, center vertically. If $false, do not change vertical location.]]
         }
      }
      keygrab_set {
         [[Set keygrab value of the window

           This function grabs the $key of window using $grab_mode.
         ]]

         return: bool; [[$true on success, $false otherwise]]
         params {
            @in key: string; [[This string is the keyname to grab.]]
            @in modifiers: Efl.Input.Modifier; [[A combination of modifier keys
                 that must be present to trigger the event. Not supported yet.]]
            @in not_modifiers: Efl.Input.Modifier; [[A combination of modifier
                 keys that must not be present to trigger the event. Not supported yet.]]
            @in priority: int; [[Not supported yet.]]
            @in grab_mode: Efl.Ui.Win_Keygrab_Mode; [[Describes how the key should
                 be grabbed, wrt. focus and stacking.]]
         }
         legacy: null;
      }
      keygrab_unset {
         [[Unset keygrab value of the window

           This function unset keygrab value. Ungrab $key of window.
         ]]
         return: bool; [[$true on success, $false otherwise]]
         params {
            @in key: string; [[This string is the keyname to grab.]]
            @in modifiers: Efl.Input.Modifier; [[A combination of modifier keys
                 that must be present to trigger the event. Not supported yet.]]
            @in not_modifiers: Efl.Input.Modifier; [[A combination of modifier keys
                 that must not be present to trigger the event. Not supported yet.]]
         }
         legacy: null;
      }
      move_resize_start {
         [[Start moving or resizing the window.

           The user can request the display server to start moving or resizing
           the window by combining modes from @Efl.Ui.Win_Move_Resize_Mode.
           This API can only be called if none of the following conditions is
           true:

           1. Called in the absence of a pointer down event,
           2. Called more than once before a pointer up event,
           3. Called when the window is already being resized or moved,
           4. Called with an unsupported combination of modes.

           Right usage:
           1. Pointer (mouse or touch) down event,
           2. @.move_resize_start called only once with a supported mode,
           3. Pointer (mouse or touch) up event.

           If a pointer up event occurs after calling the function, it
           automatically ends the window move and resize operation.

           Currently, only the following 9 combinations are allowed, and
           possibly more combinations may be added in the future:
           1. @Efl.Ui.Win_Move_Resize_Mode.move
           2. @Efl.Ui.Win_Move_Resize_Mode.top
           3. @Efl.Ui.Win_Move_Resize_Mode.bottom
           4. @Efl.Ui.Win_Move_Resize_Mode.left
           5. @Efl.Ui.Win_Move_Resize_Mode.right
           6. @Efl.Ui.Win_Move_Resize_Mode.top | @Efl.Ui.Win_Move_Resize_Mode.left
           7. @Efl.Ui.Win_Move_Resize_Mode.top | @Efl.Ui.Win_Move_Resize_Mode.right
           8. @Efl.Ui.Win_Move_Resize_Mode.bottom | @Efl.Ui.Win_Move_Resize_Mode.left
           9. @Efl.Ui.Win_Move_Resize_Mode.bottom | @Efl.Ui.Win_Move_Resize_Mode.right

           In particular move and resize cannot happen simultaneously.

           Note: the result of this API can only guarantee that the request has
           been forwarded to the server, but there is no guarantee that the
           request can be processed by the display server.

           @since 1.19
         ]]
         return: bool; [[$true if the request was successfully sent to the
                         display server, $false in case of error.]]
         params {
            @in mode: Efl.Ui.Win_Move_Resize_Mode; [[The requested move or
                                                     resize mode.]]
         }
      }
      @property hint_base {
         [[Base size for objects with sizing restrictions.

           This is not a size enforcement in any way, it's just a hint
           that should be used whenever appropriate.

           @.hint_base + N x @.hint_step is what is calculated for object
           sizing restrictions.

           See also @.hint_step.
         ]]
         values {
            sz: Eina.Size2D; [[Base size (hint) in pixels.]]
         }
      }
      @property hint_step {
         [[Step size for objects with sizing restrictions.

           This is not a size enforcement in any way, it's just a hint
           that should be used whenever appropriate.

           Set this to for an object to scale up by steps and not continuously.

           @.hint_base + N x @.hint_step is what is calculated for object
           sizing restrictions.
         ]]
         values {
            sz: Eina.Size2D; [[Step size (hint) in pixels.]]
         }
      }
      /* FIXME: maybe not necessary if gesture supports this */
      pointer_iterate @const @beta {
         [[Returns an iterator over the current known pointer positions.

           This is used to iterate over the current known multi-touch positions,
           including the first finger. Each pointer position is represented by
           an object of type @Efl.Input.Pointer.

           Each finger in a multi touch environment can then be identified
           by the @Efl.Input.Pointer.tool property. The order of the pointers
           in this iterator is not defined.

           Note: If the input surface supports hovering input, some pointers
           may not be in a "down" state. To retrieve the list of such pointers,
           set the $hover value to $true. Remember though that most devices
           currently don't support this.
         ]]
         params {
            /* FIXME: missing seat. hover is not useful */
            hover: bool @optional; [[$false by default, $true means to include
                                     fingers that are currently hovering.]]
         }
         return: iterator<const(Efl.Input.Pointer)>; [[Iterator to pointer positions]]
      }
      @property rotation {
         [[The rotation of this window

           The value will automatically change when the WM of this window changes its rotation. This rotation is automatically applied to all @Efl.Ui.Layout objects.
         ]]
         set {
          legacy: null;
         }
         get {
          legacy: null;
         }
         values {
           rotation : Efl.Orient; [[The rotation of the window]]
         }
      }
   }
   implements {
      class.constructor;
      Efl.Object.constructor;
      Efl.Object.destructor;
      Efl.Object.provider_find;
      Efl.Object.finalize;
      Efl.Object.debug_name_override;
      Efl.Gfx.Entity.visible { set; }
      Efl.Gfx.Entity.position { set; }
      Efl.Gfx.Entity.size { set; }
      Efl.Gfx.Stack.raise_to_top; [[Places the window at the top of the stack, so
                                   that it's not covered by any other window.]]
      Efl.Gfx.Stack.lower_to_bottom; [[This action is ignored by the Window.]]
      Efl.Ui.Widget.theme_apply;
      Efl.Ui.Focus.Object.focus { get; }
      Efl.Ui.Widget.focus_highlight_style { get; set; }
      Efl.Ui.Widget.focus_highlight_enabled { get; set; }
      Efl.Ui.Widget.focus_highlight_animate { get; set; }
      Efl.Ui.Focus.Object.on_focus_update;
      Efl.Ui.Widget.widget_event;
      Efl.Ui.Widget_Focus_Manager.focus_manager_create;
      Efl.Access.Object.state_set { get; }
      Efl.Access.Object.i18n_name { get; }
      Efl.Access.Component.extents { get; }
      Efl.Access.Widget.Action.elm_actions { get; }
      Efl.Input.State.modifier_enabled { get; }
      Efl.Input.State.lock_enabled { get; }
      Efl.Screen.screen_dpi { get; }
      Efl.Screen.screen_rotation { get; }
      Efl.Screen.screen_size_in_pixels { get; }
      Efl.Gfx.Hint.hint_aspect { set; }
      Efl.Gfx.Hint.hint_weight { set; }
      Efl.Gfx.Hint.hint_size_max { set; }
      Efl.Text.text { get; set; }
      Efl.Canvas.Scene.seat_default { get; }
      Efl.Canvas.Scene.pointer_position { get; }
      Efl.Canvas.Pointer.pointer_inside { get; }
      Efl.Canvas.Scene.image_max_size { get; }
      Efl.Canvas.Scene.group_objects_calculate;
      Efl.Canvas.Scene.objects_at_xy_get;
      Efl.Canvas.Scene.object_top_at_xy_get;
      Efl.Canvas.Scene.objects_in_rectangle_get;
      Efl.Canvas.Scene.object_top_in_rectangle_get;
      Efl.Canvas.Scene.device { get; }
      Efl.Canvas.Scene.seat { get; }
      Efl.Content.content { get; set; }
      Efl.Content.content_unset;
      Efl.Part.part_get;
   }
   constructors {
      .win_name @optional;
      .win_type @optional;
      .accel_preference @optional;
   }
   events {
      delete,request: void; [[Called when the window receives a delete request]]
      withdrawn: void; [[Called when window is withdrawn]]
      iconified: void; [[Called when window is iconified]]
      normal: void; [[Called when window is set to normal state]]
      stick: void; [[Called when window is set as sticky]]
      unstick: void; [[Called when window is no  longer set as sticky]]
      fullscreen: void; [[Called when window is set to fullscreen]]
      unfullscreen: void; [[Called when window is no longer set to fullscreen]]
      maximized: void; [[Called when window is set to maximized]]
      unmaximized: void; [[Called when window is no longer set to maximized]]
      indicator,prop,changed: void; [[Called when indicator is property changed]]
      rotation,changed: void; [[Called when window rotation is changed]]
      profile,changed: void; [[Called when profile is changed]]
      wm,rotation,changed: void; [[Called when window manager rotation is changed]]
      theme,changed: void; [[Called when theme is changed]]
      elm,action,block_menu: void; [[Called when elementary block menu action occurs]]
      pause: void; [[Called when the window is not going be displayed for some time]]
      resume: void; [[Called before a window is rendered after a pause event]]
   }
   composite {
      Efl.Config;
   }
}
